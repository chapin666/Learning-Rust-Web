## 为什么要松耦合

您是否曾经遇到过这样的情况: 应用程序中的更改导致应用程序中完全不同的部分出现奇怪的 bug？ 或者你是否至少经历过一次 API 崩溃?

通过让应用程序的不同部分尽可能少地了解彼此，可以减少出现这些问题的机会。 这是一种称为松散耦合的建筑设计。

如果您需要松耦合的应用程序，那么将其拆分为更小的服务也要容易得多。 如果你曾经考虑过把你的单体服务分割成微型服务，这将会很有帮助。

我发现很难找到一些关于如何构建松散耦合应用程序的好实例。 因此，这里有一些技巧，您可以遵循，使您的应用程序更松散地耦合。

### 项目结构

假设您有一个类似这样的项目结构

```
.
├── routes
|   ├──order.rs
|   └── user.rs
├── events
|   ├──order.rs
|   └── user.js
├── models
|   ├── order.rs
|   └── user.rs
```

对于这样的项目结构，您需要打开几个文件夹来理解每个特性是如何工作的。 当功能列表增加时，我发现很难浏览，因为我不得不同时打开几个文件夹。 虽然大部分内容在给定的时间是无关紧要的，因为我通常一次只处理一个特性。

而且，如果我们想把它分成几个服务，我们必须通过几个不同的文件夹来连接我们需要的部分。

另一种方法是按功能对文件夹进行分组，如下所示。

 ```
.
├── order
|   ├──mod.rs
|   ├──routes.rs
|   ├──events.rs
|   └── model.rs
├── user
|   ├──mod.rs
|   ├──routes.rs
|   ├──events.rs
|   └── model.rs
 ```

有了这样的结构，就更容易了解每个特性是如何工作的。 在这里，我们只需要为我们正在处理的每个特性打开一个小文件夹。 而且由于属于一起的文件被放在一起，导航也变得更加容易。

### 组件间交互

如果让应用程序的不同部分修改数据库中的用户数据，会发生什么情况？ 它可能会起作用，但是一般来说，这不是一个好主意，因为你最终会得到两种不同的方法，这两种方法可能会导致彼此冲突。

假设一种方法具有内置缓存，而另一种则不在乎，因为它只是一种快速而简单的实现。 如果现在使用第二种方法更新数据库，则最终将导致无效的缓存。

如果应用程序的不同部分在同一个数据库中更改数据，就很难大致了解是谁在进行这些更改。 如果您不知道是谁在做这些更改，那么当您发现一个 bug 时，调试代码也会很困难。 同样，如果你不能很容易地了解到哪些部分是连接在一起的，那么将整体分解成微型服务几乎是不可能的。

如果我们更愿意让应用程序的不同部分通过 api 进行交互，那么理解不同部分是如何连接在一起就会容易得多。 我们甚至可以通过搜索 API 的引用来查看 API 使用的所有地方。 另一个优点是，我们可以重写 API，而不影响使用它的部分。 例如，如果您认为某个 API 被大量使用，并且需要添加缓存，那么这可能会有所帮助。

那么一个好的 API 是什么样的呢？ 我能给出的最好的建议就是保持简单。 例如，如果您想创建一个用于查找用户的 API，那么只需要传递 id 就足够了。

```
#[get("/users/{id}")]
fn find(id: web::Path<Uuid>) -> Result<HttpResponse, ApiError> {
    let user = User::find(id.into_inner())?;
    Ok(HttpResponse::Ok().json(user))
}
```

我在 rust 社区中看到了很多这样的例子，API 连接需要像这样传递给 API。

```
#[get("/users/{id}")]
fn find(conn: web::Data<PgConnection>, id: web::Path<Uuid>) -> Result<HttpResponse, ApiError> {
    let user = User::find(conn.into_inner(), id.into_inner())?;
    Ok(HttpResponse::Ok().json(user))
}
```

采取这种方法你可能马上不会有任何问题。 但是，在某个时候想要对这个 API 做任何更改，比如添加缓存或可能发布或订阅事件队列。

通过向 API 添加或删除参数，我们将使其中断。 如果我们想要解决这个问题，我们必须在每个使用这个 API 的地方添加这个新参数。 在小项目中，这可能是可行的，但是对于由几个开发人员维护的大项目呢？

### 向微型服务迈进

我不建议从微服务体系结构开始，因为这会给您的项目带来相当大的开销。 但是，如果你在某个时候得到了很多客户，你可能不得不扩大规模。 一种方法是将应用程序划分为几个较小的服务，使每个服务的负载较小。

如果您遵循上面的提示，那么将应用程序的不同部分拆分为更小的服务就会容易得多。 只需将每个功能的文件夹拖放到新服务中，就可以很容易地做到这一点。

但是等等，这会破坏我们的 api，不是吗？ 是的，它会，但它实际上是一个相当容易的解决方案，因为我们的 API 的所有用户不作任何假设的 API 是如何工作的。 这意味着我们可以重写 api 来对新创建的服务进行远程过程调用，该服务将处理请求。 而且 API 的用户不需要做任何更改，因为 API 看起来还是一样的。


### 后续

下一篇博文将是关于如何使用 Rust、 activex Web 和 Diesel 创建 REST API 的教程。